import{_ as e,c as s,a7 as t,o as i}from"./chunks/framework.DKOW1EBX.js";const l="/blog/assets/lifecycle_hooks.D5p6yF0g.png",u=JSON.parse('{"title":"VUE 查漏补缺","description":"","frontmatter":{},"headers":[],"relativePath":"docs/frontend/八股文/VUE.md","filePath":"docs/frontend/八股文/VUE.md","lastUpdated":1736738356000}'),c={name:"docs/frontend/八股文/VUE.md"};function o(n,a,d,h,p,r){return i(),s("div",null,a[0]||(a[0]=[t('<h1 id="vue-查漏补缺" tabindex="-1">VUE 查漏补缺 <a class="header-anchor" href="#vue-查漏补缺" aria-label="Permalink to &quot;VUE 查漏补缺&quot;">​</a></h1><h2 id="表单输入绑定" tabindex="-1">表单输入绑定 <a class="header-anchor" href="#表单输入绑定" aria-label="Permalink to &quot;表单输入绑定&quot;">​</a></h2><blockquote><p><code>v-model</code> 会根据各种不同类型的输入，<code>textarea</code> <code>&lt;select&gt;</code> 元素。它会根据所使用的元素自动使用对应的 DOM 属性和事件组合。</p></blockquote><ul><li>文本类型的<code>&lt;input&gt;</code> 和 <code>&amp;lt;textarea&gt;</code> 元素绑定 <code>value</code> 属性和监听 <code>input</code> 事件</li><li><code>&lt;input type=&quot;checkbox&quot;&gt;, &lt;input type=&quot;radio&quot;&gt;</code> 绑定 <code>check</code> 属性和监听 <code>change</code> 事件</li><li>&lt;select&gt; 绑定 <code>value</code> 属性和监听 <code>change</code> 事件</li></ul><h2 id="生命周期构子" tabindex="-1">生命周期构子 <a class="header-anchor" href="#生命周期构子" aria-label="Permalink to &quot;生命周期构子&quot;">​</a></h2><p><img src="'+l+'" alt="alt" loading="lazy"></p><h2 id="侦听器-watch-watcheffect" tabindex="-1">侦听器（<code>watch</code>, <code>watchEffect</code>） <a class="header-anchor" href="#侦听器-watch-watcheffect" aria-label="Permalink to &quot;侦听器（`watch`, `watchEffect`）&quot;">​</a></h2><ul><li>回调触发时机：在<strong>父组件</strong>更新(如有)之后，所属组件的DOM更新之前被调用。如果你尝试在侦听器回调中访问所属组件的 DOM，那么 DOM 将处于 <strong>更新前</strong> 的状态。</li><li>Post Watchers 能让回调获取Vue更新之后的所属组件的DOM。需要指明 <code>flush: &#39;post&#39;;</code></li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">watch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(source, callback, { flush: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;post&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> });</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">watchEffect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(callback, { flush: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;post&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> });</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 别名</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">watchPostEffect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(callback);</span></span></code></pre></div><ul><li>同步侦听器： 在Vue进行任何更新之前触发； <code>{ flush: &#39;sync&#39; }</code></li></ul><div class="warning custom-block"><p class="custom-block-title">注意</p><p>同步创建的侦听器会绑定在组件实例上，随组件卸载自动停止； 异步创建的侦听器（在生命周期回调创建）需要手动停止；</p></div>',11)]))}const g=e(c,[["render",o]]);export{u as __pageData,g as default};
