import{_ as t,c as i,a7 as e,o as n}from"./chunks/framework.DKOW1EBX.js";const f=JSON.parse('{"title":"持续集成（Continuous Integration）","description":"","frontmatter":{},"headers":[],"relativePath":"docs/frontend/持续集成.md","filePath":"docs/frontend/持续集成.md","lastUpdated":1740069447000}'),o={name:"docs/frontend/持续集成.md"};function l(r,a,s,d,u,c){return n(),i("div",null,a[0]||(a[0]=[e('<h1 id="持续集成-continuous-integration" tabindex="-1">持续集成（Continuous Integration） <a class="header-anchor" href="#持续集成-continuous-integration" aria-label="Permalink to &quot;持续集成（Continuous Integration）&quot;">​</a></h1><h2 id="持续集成的好处" tabindex="-1">持续集成的好处 <a class="header-anchor" href="#持续集成的好处" aria-label="Permalink to &quot;持续集成的好处&quot;">​</a></h2><ul><li>持续性的代码检查可以尽早地发现错误，而且错误也比较容易理解和处理，反之非持续性的代码检查，可能会发现一堆的错误，失之毫厘谬以千里，错误相互牵连，最终会变得难以收拾。</li><li>自动化工作流，减少人工干预。人类比机器容易犯错, 而且机器擅长做重复的事情</li></ul><h2 id="持续集成规范" tabindex="-1">持续集成规范： <a class="header-anchor" href="#持续集成规范" aria-label="Permalink to &quot;持续集成规范：&quot;">​</a></h2><ul><li>执行环境：规定容器、Node版本、操作系统等；</li><li>触发条件：定时触发、分支触发等；</li><li>执行的任务：</li><li>划分持续集成的阶段</li><li>定义持续集成脚本模板</li></ul><h2 id="常用ci" tabindex="-1">常用CI <a class="header-anchor" href="#常用ci" aria-label="Permalink to &quot;常用CI&quot;">​</a></h2><ul><li>github: travis CI, Circle CI, github action</li><li>gitlab: Gitlab-CI</li><li>通用: Jenkins</li></ul>',7)]))}const m=t(o,[["render",l]]);export{f as __pageData,m as default};
