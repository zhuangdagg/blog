# 查漏补缺

## 什么是 **包装类型**

> 在 JavaScript 中，`基本类型` 是没有 `属性` 和 `方法` 的，但是为了便于操
作基本类型的值，在调用基本类型的属性或方法时 JavaScript 会在
后台 `隐式` 地将基本类型的值转换为 `对象`

```js
let str = 'abc';
str.length; // 3  String(str).length
str.toUpperCase(); // 'ABC'

// 显式转换为包装类型
let strObj = Object(str)  // String {"abc"}

// 包装类型转换为基本类型
strObj.valueOf() // 'abc'

let falseObj = new Boolean(false); // Boolean {false}

falseObj == false // true
falseObj === false // false
!falseObj // false
```

## 字符串转为数组
```js
// 方法一 
'hello'.split('') // ['h', 'e', 'l', 'l', 'o']
// 方法二 使用扩展运算符
[...'hello'] // ['h', 'e', 'l', 'l', 'o']
```

## Proxy 实现功能
1. 通过 Proxy 来实现一个数据响应式
[示例](/js-playground#proxy-example){target=_blank}
2. 

## JSON.parse(JSON.stringify(...)) 实现硬拷贝

[示例](/js-playground#parse-stringify-copy){target=_blank}

## 原型与原型链相关
1. 对象有__proto__属性，函数有__proto__属性，数组也有__proto__属性，只要是引用类型，就有__proto__属性，指向其原型。
2. 只有函数有prototype属性，只有函数有prototype属性，只有函数有prototype属性，指向new操作符加调用该函数创建的对象实例的原型对象。

![alt](/assets/capture/prototype_relate.png)

[查阅](https://segmentfault.com/a/1190000042725370)

`Object.prototype.__proto__ === null`

```js
Object.prototype.constructor === Object // true
```

## 作用域链
> 当前作用域中查找所需变量，但是该作用域没有这个变量，那这个
变量就是自由变量。如果在自己作用域找不到该变量就去父级作用域
查找，依次向上级作用域查找，直到访问到window对象就被终止，
这一层层的关系就是作用域链。

## 对 `this` 的理解
> this 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。
调用模式：
- **函数调用** 当一个函数不是一个对象的属性时，直接作为函数来调用时，this 指向全局对象。
- **方法调用** 如果一个函数作为一个对象的方法来调用时，this 指向这个对象
- **构造器调用** 如果一个函数用 new 调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象。
- **apply,call,bind调用**

四种模式优先级： `构造器` > `apply,call,bind` > `方法调用` > `函数调用`

## 异步编程的实现方式
- `回调函数` 缺点：callback hell
- `Promise` 链式调用，有时会造成多个 then 的链式调用，缺点：可能会造成代码的语义不够明确
- `generator`: co模块等方式来实现 generator 的自动执行；
- `async 函数`: async 函数是 generator 和 promise 实现的一个自动执行的语法糖